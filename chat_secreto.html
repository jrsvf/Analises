<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Secreto WebRTC - Funcional</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #333;
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .container {
            max-width: 800px;
            width: 100%;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 20px;
            background: #2c3e50;
            color: white;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1rem;
            opacity: 0.9;
        }
        
        .config-card {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }
        
        .config-card h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3498db;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .input-group input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }
        
        button {
            padding: 10px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        button:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }
        
        .danger {
            background: #e74c3c;
        }
        
        .danger:hover {
            background: #c0392b;
        }
        
        .success {
            background: #2ecc71;
        }
        
        .success:hover {
            background: #27ae60;
        }
        
        .chat-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: #2c3e50;
            color: white;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        
        .messages {
            height: 300px;
            overflow-y: auto;
            padding: 15px;
            background: white;
            border-radius: 5px;
            border: 1px solid #ddd;
            margin-bottom: 15px;
        }
        
        .message {
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            max-width: 80%;
        }
        
        .message.local {
            background: #d4edda;
            margin-left: auto;
            text-align: right;
        }
        
        .message.remote {
            background: #f8d7da;
        }
        
        .message.info {
            background: #d1ecf1;
            text-align: center;
            max-width: 100%;
        }
        
        .message-input {
            display: flex;
            gap: 10px;
        }
        
        .message-input input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .instructions {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }
        
        .instructions h3 {
            color: #856404;
            margin-bottom: 10px;
        }
        
        .instructions ol {
            margin-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
        
        .connection-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .offer-answer-box {
            background: #e9ecef;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 0.8rem;
            max-height: 100px;
            overflow-y: auto;
            word-break: break-all;
        }
        
        .debug-info {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            font-size: 0.8rem;
        }
        
        .debug-info h3 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .debug-toggle {
            background: #6c757d;
            font-size: 0.8rem;
            padding: 5px 10px;
        }
        
        #debug-content {
            display: none;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Chat Secreto WebRTC</h1>
            <p class="subtitle">Conexão direta entre navegadores - Corrigido e Funcional</p>
        </header>
        
        <div class="instructions">
            <h3>Como usar (MUITO IMPORTANTE):</h3>
            <ol>
                <li>Abra esta página em duas janelas/abas do <strong>mesmo navegador</strong></li>
                <li>Em uma janela, clique em <strong>"Criar Conexão"</strong> (você será o Iniciador)</li>
                <li>Na outra janela, clique em <strong>"Conectar"</strong> (você será o Receptor)</li>
                <li>Aguarde alguns segundos até o status mudar para "Conectado"</li>
                <li>Digite mensagens e clique em Enviar ou pressione Enter</li>
                <li><strong>Dica:</strong> Se não funcionar de imediato, recarregue as páginas e tente novamente</li>
            </ol>
        </div>
        
        <div class="config-card">
            <h2>Configurações</h2>
            <div class="input-group">
                <label for="nickname">Seu Apelido</label>
                <input type="text" id="nickname" placeholder="Digite seu apelido" value="Usuário">
            </div>
            
            <div class="status-bar">
                <span id="status-display">Status: Desconectado</span>
                <span id="connection-state">Estado: -</span>
            </div>
            
            <div class="connection-buttons">
                <button id="create-connection" class="success">Criar Conexão (Iniciador)</button>
                <button id="connect" class="success">Conectar (Receptor)</button>
                <button id="disconnect" class="danger" disabled>Desconectar</button>
                <button id="clear-messages" class="danger">Limpar Chat</button>
            </div>
        </div>
        
        <div class="chat-section">
            <h2>Chat</h2>
            <div class="messages" id="messages">
                <div class="message info">Sistema: Conecte-se para começar a conversar</div>
            </div>
            <div class="message-input">
                <input type="text" id="message-input" placeholder="Digite sua mensagem..." disabled>
                <button id="send-message" disabled>Enviar</button>
            </div>
        </div>
        
        <div class="debug-info">
            <h3>Informações de Debug <button id="toggle-debug" class="debug-toggle">Mostrar/Ocultar</button></h3>
            <div id="debug-content">
                <p><strong>Estado da Conexão:</strong> <span id="debug-connection-state">-</span></p>
                <p><strong>Sinalização:</strong> <span id="debug-signaling-state">-</span></p>
                <p><strong>Canal de Dados:</strong> <span id="debug-data-channel">-</span></p>
                <p><strong>Último Erro:</strong> <span id="debug-last-error">Nenhum</span></p>
            </div>
        </div>
    </div>

    <script>
        // Configurações e elementos do DOM
        const nicknameInput = document.getElementById('nickname');
        const statusDisplay = document.getElementById('status-display');
        const connectionStateDisplay = document.getElementById('connection-state');
        const messagesContainer = document.getElementById('messages');
        const messageInput = document.getElementById('message-input');
        const sendMessageButton = document.getElementById('send-message');
        
        // Elementos de debug
        const debugConnectionState = document.getElementById('debug-connection-state');
        const debugSignalingState = document.getElementById('debug-signaling-state');
        const debugDataChannel = document.getElementById('debug-data-channel');
        const debugLastError = document.getElementById('debug-last-error');
        const toggleDebugButton = document.getElementById('toggle-debug');
        const debugContent = document.getElementById('debug-content');
        
        // Botões
        const createConnectionButton = document.getElementById('create-connection');
        const connectButton = document.getElementById('connect');
        const disconnectButton = document.getElementById('disconnect');
        const clearMessagesButton = document.getElementById('clear-messages');
        
        // Variáveis globais WebRTC
        let peerConnection = null;
        let dataChannel = null;
        let isInitiator = false;
        let makingOffer = false;
        
        // Configuração dos servidores STUN
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };
        
        // Servidor de sinalização simplificado usando localStorage
        const signalingChannel = {
            sendOffer: (offer) => {
                localStorage.setItem('webrtc_offer', JSON.stringify(offer));
                localStorage.setItem('webrtc_signal', 'offer');
                console.log('Oferta enviada para sinalização');
            },
            
            sendAnswer: (answer) => {
                localStorage.setItem('webrtc_answer', JSON.stringify(answer));
                localStorage.setItem('webrtc_signal', 'answer');
                console.log('Resposta enviada para sinalização');
            },
            
            sendIceCandidate: (candidate) => {
                localStorage.setItem('webrtc_ice_candidate', JSON.stringify(candidate));
                localStorage.setItem('webrtc_signal', 'ice_candidate');
            },
            
            onOffer: (callback) => {
                const checkForOffer = () => {
                    const signal = localStorage.getItem('webrtc_signal');
                    if (signal === 'offer') {
                        const offer = localStorage.getItem('webrtc_offer');
                        if (offer) {
                            callback(JSON.parse(offer));
                        }
                    }
                };
                return setInterval(checkForOffer, 1000);
            },
            
            onAnswer: (callback) => {
                const checkForAnswer = () => {
                    const signal = localStorage.getItem('webrtc_signal');
                    if (signal === 'answer') {
                        const answer = localStorage.getItem('webrtc_answer');
                        if (answer) {
                            callback(JSON.parse(answer));
                        }
                    }
                };
                return setInterval(checkForAnswer, 1000);
            },
            
            onIceCandidate: (callback) => {
                const checkForIceCandidate = () => {
                    const signal = localStorage.getItem('webrtc_signal');
                    if (signal === 'ice_candidate') {
                        const candidate = localStorage.getItem('webrtc_ice_candidate');
                        if (candidate) {
                            callback(JSON.parse(candidate));
                            localStorage.removeItem('webrtc_signal');
                            localStorage.removeItem('webrtc_ice_candidate');
                        }
                    }
                };
                return setInterval(checkForIceCandidate, 1000);
            },
            
            clear: () => {
                localStorage.removeItem('webrtc_signal');
                localStorage.removeItem('webrtc_offer');
                localStorage.removeItem('webrtc_answer');
                localStorage.removeItem('webrtc_ice_candidate');
            }
        };
        
        // Intervalos para verificação de sinalização
        let offerInterval, answerInterval, iceInterval;
        
        // Atualizar status da conexão
        function updateConnectionStatus(status, state) {
            statusDisplay.textContent = `Status: ${status}`;
            if (state) {
                connectionStateDisplay.textContent = `Estado: ${state}`;
                debugConnectionState.textContent = state;
            }
            
            if (status === 'Conectado') {
                disconnectButton.disabled = false;
                messageInput.disabled = false;
                sendMessageButton.disabled = false;
                messageInput.focus();
                createConnectionButton.disabled = true;
                connectButton.disabled = true;
            } else {
                disconnectButton.disabled = true;
                messageInput.disabled = true;
                sendMessageButton.disabled = true;
                createConnectionButton.disabled = false;
                connectButton.disabled = false;
            }
        }
        
        // Atualizar estado de sinalização
        function updateSignalingState(state) {
            debugSignalingState.textContent = state;
        }
        
        // Atualizar estado do canal de dados
        function updateDataChannelState(state) {
            debugDataChannel.textContent = state;
        }
        
        // Registrar erro
        function logError(error) {
            console.error('Erro WebRTC:', error);
            debugLastError.textContent = error.message || String(error);
            addMessage(`Erro: ${error.message || String(error)}`, 'info');
        }
        
        // Adicionar mensagem ao chat
        function addMessage(text, type = 'info') {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', type);
            messageElement.textContent = text;
            messagesContainer.appendChild(messageElement);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        // Inicializar conexão PeerConnection
        function initializePeerConnection() {
            // Limpar conexão anterior se existir
            if (peerConnection) {
                peerConnection.close();
            }
            
            peerConnection = new RTCPeerConnection(configuration);
            updateSignalingState(peerConnection.signalingState);
            
            // Manipular candidatos ICE
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    signalingChannel.sendIceCandidate(event.candidate);
                }
            };
            
            // Manipular mudanças de estado da conexão
            peerConnection.onconnectionstatechange = () => {
                updateConnectionStatus(peerConnection.connectionState, peerConnection.connectionState);
                
                if (peerConnection.connectionState === 'connected') {
                    addMessage('Sistema: Conexão estabelecida com sucesso!', 'info');
                } else if (peerConnection.connectionState === 'disconnected' || 
                           peerConnection.connectionState === 'failed') {
                    addMessage('Sistema: Conexão perdida', 'info');
                    cleanupConnection();
                }
            };
            
            // Manipular mudanças de estado de sinalização
            peerConnection.onsignalingstatechange = () => {
                updateSignalingState(peerConnection.signalingState);
            };
            
            // Criar canal de dados se for o iniciador
            if (isInitiator) {
                dataChannel = peerConnection.createDataChannel('chatChannel');
                setupDataChannel();
            }
            
            // Manipular canal de dados remoto
            peerConnection.ondatachannel = (event) => {
                dataChannel = event.channel;
                setupDataChannel();
            };
            
            // Configurar intervalos para verificação de sinalização
            if (isInitiator) {
                // Iniciador espera pela resposta
                if (answerInterval) clearInterval(answerInterval);
                answerInterval = signalingChannel.onAnswer(async (answer) => {
                    try {
                        if (!peerConnection.currentRemoteDescription) {
                            await peerConnection.setRemoteDescription(answer);
                            addMessage('Sistema: Resposta recebida. Conectando...', 'info');
                        }
                    } catch (error) {
                        logError(error);
                    }
                });
            } else {
                // Receptor espera pela oferta
                if (offerInterval) clearInterval(offerInterval);
                offerInterval = signalingChannel.onOffer(async (offer) => {
                    try {
                        if (!peerConnection.currentRemoteDescription) {
                            await peerConnection.setRemoteDescription(offer);
                            addMessage('Sistema: Oferta recebida. Criando resposta...', 'info');
                            
                            const answer = await peerConnection.createAnswer();
                            await peerConnection.setLocalDescription(answer);
                            signalingChannel.sendAnswer(answer);
                            addMessage('Sistema: Resposta enviada. Conectando...', 'info');
                        }
                    } catch (error) {
                        logError(error);
                    }
                });
            }
            
            // Configurar para receber candidatos ICE
            if (iceInterval) clearInterval(iceInterval);
            iceInterval = signalingChannel.onIceCandidate(async (candidate) => {
                try {
                    await peerConnection.addIceCandidate(candidate);
                } catch (error) {
                    logError(error);
                }
            });
        }
        
        // Configurar canal de dados
        function setupDataChannel() {
            if (!dataChannel) return;
            
            updateDataChannelState('Aguardando abertura...');
            
            dataChannel.onopen = () => {
                updateConnectionStatus('Conectado', peerConnection.connectionState);
                updateDataChannelState(`Aberto (${dataChannel.readyState})`);
                addMessage('Sistema: Conexão estabelecida!', 'info');
            };
            
            dataChannel.onclose = () => {
                updateDataChannelState('Fechado');
                addMessage('Sistema: Conexão fechada', 'info');
            };
            
            dataChannel.onmessage = (event) => {
                addMessage(event.data, 'remote');
            };
            
            dataChannel.onerror = (error) => {
                logError(error);
                updateDataChannelState('Erro');
            };
        }
        
        // Iniciar como ofertante (criar oferta)
        async function startAsInitiator() {
            isInitiator = true;
            makingOffer = true;
            
            initializePeerConnection();
            createConnectionButton.disabled = true;
            addMessage('Sistema: Criando conexão...', 'info');
            
            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                signalingChannel.sendOffer(offer);
                addMessage('Sistema: Oferta criada. Aguardando resposta...', 'info');
                makingOffer = false;
            } catch (error) {
                logError(error);
                createConnectionButton.disabled = false;
                makingOffer = false;
            }
        }
        
        // Conectar como receptor
        async function connectAsReceiver() {
            isInitiator = false;
            connectButton.disabled = true;
            addMessage('Sistema: Aguardando oferta...', 'info');
            
            initializePeerConnection();
        }
        
        // Limpar conexão
        function cleanupConnection() {
            if (dataChannel) {
                dataChannel.close();
            }
            if (peerConnection) {
                peerConnection.close();
            }
            
            peerConnection = null;
            dataChannel = null;
            isInitiator = false;
            makingOffer = false;
            
            // Parar intervalos de verificação
            if (offerInterval) clearInterval(offerInterval);
            if (answerInterval) clearInterval(answerInterval);
            if (iceInterval) clearInterval(iceInterval);
            
            updateConnectionStatus('Desconectado', '-');
            updateSignalingState('-');
            updateDataChannelState('-');
            
            // Limpar sinalização
            signalingChannel.clear();
        }
        
        // Event Listeners
        createConnectionButton.addEventListener('click', startAsInitiator);
        
        connectButton.addEventListener('click', connectAsReceiver);
        
        sendMessageButton.addEventListener('click', () => {
            const message = messageInput.value.trim();
            if (message && dataChannel && dataChannel.readyState === 'open') {
                const nickname = nicknameInput.value || 'Anônimo';
                const fullMessage = `${nickname}: ${message}`;
                
                dataChannel.send(fullMessage);
                addMessage(fullMessage, 'local');
                messageInput.value = '';
            }
        });
        
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessageButton.click();
            }
        });
        
        clearMessagesButton.addEventListener('click', () => {
            messagesContainer.innerHTML = '';
            addMessage('Sistema: Mensagens limpas', 'info');
        });
        
        disconnectButton.addEventListener('click', () => {
            addMessage('Sistema: Desconectando...', 'info');
            cleanupConnection();
            addMessage('Sistema: Desconectado', 'info');
        });
        
        toggleDebugButton.addEventListener('click', () => {
            debugContent.style.display = debugContent.style.display === 'none' ? 'block' : 'none';
            toggleDebugButton.textContent = debugContent.style.display === 'none' ? 
                'Mostrar' : 'Ocultar';
        });
        
        // Inicialização
        updateConnectionStatus('Desconectado');
        
        // Verificar se já há uma oferta ou resposta
        window.addEventListener('load', () => {
            const signal = localStorage.getItem('webrtc_signal');
            if (signal === 'offer') {
                addMessage('Sistema: Há uma oferta pendente. Clique em "Conectar" para aceitar.', 'info');
            } else if (signal === 'answer') {
                addMessage('Sistema: Há uma resposta pendente. Você já é o iniciador?', 'info');
            }
        });
        
        // Limpar sinalização ao recarregar a página
        window.addEventListener('beforeunload', () => {
            signalingChannel.clear();
        });
    </script>
</body>
</html>
