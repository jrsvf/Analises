<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chat Secreto — PEQUENO SISTEMA</title>
  <style>
    :root{--bg:#0b0f12;--panel:#0f1417;--accent:#9b59ff;--muted:#9aa5b1}
    *{box-sizing:border-box;font-family:Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#050607 0%,var(--bg) 100%);color:#e6eef4}
    .wrap{max-width:980px;margin:28px auto;padding:20px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);box-shadow:0 6px 24px rgba(0,0,0,0.6)}
    header{display:flex;gap:12px;align-items:center}
    h1{font-size:20px;margin:0}
    .sub{color:var(--muted);font-size:13px}
    .grid{display:grid;grid-template-columns:320px 1fr;gap:16px;margin-top:16px}
    .panel{background:var(--panel);padding:12px;border-radius:10px}
    label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
    input,textarea,button,select{width:100%;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit}
    textarea{min-height:90px;resize:vertical}
    .small{font-size:12px;color:var(--muted)}
    .row{display:flex;gap:8px}

    /* chat area */
    .chat{display:flex;flex-direction:column;height:520px}
    .messages{flex:1;padding:12px;overflow:auto;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);margin-bottom:10px}
    .msg{margin:6px 0;max-width:72%}
    .me{align-self:flex-end;background:linear-gradient(90deg,rgba(155,89,255,0.12),rgba(155,89,255,0.06));padding:10px;border-radius:10px}
    .them{align-self:flex-start;background:rgba(255,255,255,0.03);padding:10px;border-radius:10px}
    .meta{font-size:11px;color:var(--muted);margin-top:6px}
    .controls{display:flex;gap:8px;align-items:center}
    .tiny{font-size:12px;padding:6px 8px}
    .danger{background:transparent;border:1px solid rgba(255,0,0,0.12);color:#ff8b8b}
    footer{margin-top:12px;display:flex;gap:8px}
    pre{white-space:pre-wrap;word-break:break-word;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;max-height:160px;overflow:auto}
    .hint{font-size:12px;color:var(--muted);margin-top:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Chat Secreto — Mini sistema</h1>
        <div class="sub">Conexão ponto-a-ponto (WebRTC). Mensagens efêmeras — somem ao recarregar.</div>
      </div>
    </header>

    <div class="grid">
      <div class="panel">
        <label>Apelido</label>
        <input id="nick" placeholder="Seu codinome (ex: Foca1)" value="" />

        <div style="height:12px"></div>
        <label>Canal de conexão (opcional)</label>
        <input id="room" placeholder="codigo curto (opcional)" />
        <div class="hint">Este campo é só para identificação visual — a troca real de sinalização é manual (copiar/colar). Use se quiser dar nome ao canal.</div>

        <hr style="margin:12px 0;border:none;border-top:1px solid rgba(255,255,255,0.03)" />

        <label>Crie o *offer* (Pessoa A)</label>
        <div class="row"><button id="createOffer">Criar Offer</button><button id="copyOffer">Copiar Offer</button></div>
        <div style="height:8px"></div>
        <label>Offer / Answer (trocar entre os dois — copiar/colar)</label>
        <textarea id="signaling" placeholder="Cole aqui o offer/answer do outro usuário"></textarea>
        <div class="row" style="margin-top:8px"><button id="setRemoteAndAnswer">Definir Offer remoto & criar Answer (Pessoa B)</button><button id="setRemoteAnswer">Setar Answer remoto (Pessoa A)</button></div>

        <div style="height:12px"></div>
        <label>Conexão</label>
        <div class="row"><button id="disconnect" class="danger tiny">Desconectar</button><button id="clearChat" class="tiny">Limpar mensagens</button></div>
        <div class="hint">Repare: presença/estado aparece quando o canal está aberto. Se a conexão falhar, verifique trocas de offer/answer ou NAT restritivo.</div>
      </div>

      <div class="panel chat">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <div>
            <strong id="labelRoom">Canal: (não conectado)</strong>
            <div class="small">Você: <span id="labelNick">—</span> • Status: <span id="status">desconectado</span></div>
          </div>
          <div class="small">Protocolo: <code>WebRTC (P2P)</code></div>
        </div>

        <div class="messages" id="messages"></div>

        <div class="meta" id="typing" style="height:18px"></div>

        <footer>
          <input id="inputMsg" placeholder="Escreva..." />
          <button id="send" class="tiny">Enviar</button>
        </footer>
      </div>
    </div>

    <div style="margin-top:12px" class="panel small">
      <strong>Como usar</strong>
      <ol>
        <li>Abra o arquivo em dois computadores (ou abas).</li>
        <li>Escolha apelidos. Pessoa A clica em <em>Criar Offer</em>, copia o texto (botão Copiar Offer) e envia (por chat, PM, etc.) para Pessoa B.</li>
        <li>Pessoa B cola o offer no campo e clica em <em>Definir Offer remoto & criar Answer</em>. Copia o Answer gerado e envia de volta para A.</li>
        <li>Pessoa A cola o Answer no campo e clica em <em>Setar Answer remoto</em>. Quando os peers conectarem, o status mudará para <em>conectado</em>.</li>
        <li>Pronto — podem trocar mensagens. Tudo é temporário: recarregar a página limpa o histórico.</li>
      </ol>
      <div class="hint">Observação: usamos um servidor STUN público para tentar atravessar NATs, mas se ambos estiverem em redes muito restritas a conexão pode falhar.</div>
    </div>
  </div>

<script>
  // Pequeno WebRTC P2P Chat com troca manual de SDP (sem servidor)
  let pc = null, dc = null;
  const cfg = {iceServers:[{urls:["stun:stun.l.google.com:19302"]}]};
  const nickInput = document.getElementById('nick');
  const roomInput = document.getElementById('room');
  const messagesEl = document.getElementById('messages');
  const statusEl = document.getElementById('status');
  const labelNick = document.getElementById('labelNick');
  const labelRoom = document.getElementById('labelRoom');
  const signaling = document.getElementById('signaling');
  const inputMsg = document.getElementById('inputMsg');

  function logMessage(text, who='them'){
    const el = document.createElement('div'); el.className='msg '+(who==='me'?'me':'them'); el.innerHTML = '<div>'+escapeHtml(text)+'</div><div class="meta">'+new Date().toLocaleTimeString()+'</div>'; messagesEl.appendChild(el); messagesEl.scrollTop = messagesEl.scrollHeight;
  }
  function escapeHtml(s){ return s.replace(/[&<>\"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

  function updateLabels(){ labelNick.textContent = nickInput.value || '—'; labelRoom.textContent = 'Canal: '+(roomInput.value || '(não nomeado)'); }
  nickInput.oninput = updateLabels; roomInput.oninput = updateLabels; updateLabels();

  function ensurePC(){ if(pc) return; pc = new RTCPeerConnection(cfg);
    pc.onicecandidate = e=>{ if(e.candidate==null){ // ICE gathering finished -> localDescription ready
        signaling.value = JSON.stringify(pc.localDescription);
      }
    };
    pc.onconnectionstatechange = ()=>{ statusEl.textContent = pc.connectionState; }
    pc.ondatachannel = ev=>{ dc = ev.channel; setupDC(); }
  }

  function setupDC(){ if(!dc) return; dc.onopen = ()=>{ statusEl.textContent='conectado'; }; dc.onclose = ()=>{ statusEl.textContent='fechado'; }; dc.onmessage = ev=>{ try{ const payload=JSON.parse(ev.data); if(payload.type==='chat'){ logMessage(payload.nick+': '+payload.text,'them'); } }catch(e){ logMessage(ev.data,'them'); } } }

  document.getElementById('createOffer').onclick = async ()=>{
    ensurePC(); dc = pc.createDataChannel('secret'); setupDC(); const offer = await pc.createOffer(); await pc.setLocalDescription(offer);
    // Wait for ICE to finish gathering (approx)
    setTimeout(()=>{ signaling.value = JSON.stringify(pc.localDescription); }, 1200);
  };

  document.getElementById('copyOffer').onclick = ()=>{ signaling.select(); document.execCommand('copy'); };

  document.getElementById('setRemoteAndAnswer').onclick = async ()=>{
    try{
      ensurePC(); const remote = JSON.parse(signaling.value); await pc.setRemoteDescription(remote);
      const answer = await pc.createAnswer(); await pc.setLocalDescription(answer);
      // wait a little for ICE candidates; copyable via textarea
      setTimeout(()=>{ signaling.value = JSON.stringify(pc.localDescription); }, 1200);
    }catch(e){ alert('Erro ao processar offer: '+e.message); }
  };

  document.getElementById('setRemoteAnswer').onclick = async ()=>{
    try{ const remote = JSON.parse(signaling.value); await pc.setRemoteDescription(remote); alert('Answer aplicada — se tudo ocorreu, a conexão começará a negociar.'); }catch(e){ alert('Erro ao setar answer: '+e.message); }
  };

  document.getElementById('disconnect').onclick = ()=>{ if(dc) dc.close(); if(pc) pc.close(); dc=null; pc=null; statusEl.textContent='desconectado'; }
  document.getElementById('clearChat').onclick = ()=>{ messagesEl.innerHTML=''; }

  document.getElementById('send').onclick = ()=>{ sendMsg(); };
  inputMsg.onkeydown = e=>{ if(e.key==='Enter'){ e.preventDefault(); sendMsg(); } }

  function sendMsg(){ if(!dc || dc.readyState!=='open'){ alert('Conexão não aberta. Faça o procedimento de offer/answer.'); return; }
    const text = inputMsg.value.trim(); if(!text) return; const payload = {type:'chat', nick: nickInput.value||'Anon', text}; dc.send(JSON.stringify(payload)); logMessage((nickInput.value||'Você')+': '+text,'me'); inputMsg.value='';
  }

  // small fallback: if both open same page and no manual signaling, allow local BroadcastChannel for single-machine test
  try{
    const bc = new BroadcastChannel('chat-secreto-local'); bc.onmessage = ev=>{ if(ev.data && ev.data.type==='chat'){ logMessage(ev.data.nick+': '+ev.data.text,'them'); } }
    // expose quick send if no P2P
    window.localBroadcastSend = (p)=>{ bc.postMessage(p); logMessage((p.nick||'Você')+': '+p.text,'me'); }
  }catch(e){/*ignore*/}

</script>
</body>
</html>
